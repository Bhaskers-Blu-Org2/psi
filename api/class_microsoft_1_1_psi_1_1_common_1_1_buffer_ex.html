<!-- Copyright (c) Microsoft Corporation. All rights reserved.
     Licensed under the MIT License. -->
<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.18" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Platform for Situated Intelligence: Microsoft.Psi.Common.BufferEx Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="customdoxygen.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">Platform for Situated Intelligence</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_microsoft.html">Microsoft</a></li><li class="navelem"><a class="el" href="namespace_microsoft_1_1_psi.html">Psi</a></li><li class="navelem"><a class="el" href="namespace_microsoft_1_1_psi_1_1_common.html">Common</a></li><li class="navelem"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html">BufferEx</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Microsoft.Psi.Common.BufferEx Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides static methods to efficiently read and write simple value types as well as arrays of simple value types from/to memory buffers (managed or unmanaged). Similar to System.Buffer, but works with any simple struct, not just primitive types. The simple value types supported by this class can only contain fields of primitive types or other simple value types. For accessing unmanaged memory as an array of strong-typed elements, see UnmanagedArray&lt;T&gt;. For efficient reading and writing of complex types, see the <a class="el" href="namespace_microsoft_1_1_psi_1_1_serialization.html">Serialization</a> namespace.  
 <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8060c14c1635a70aef6387e95a56f3c5"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a8060c14c1635a70aef6387e95a56f3c5">Read&lt; T &gt;</a> (byte[] source, int index)</td></tr>
<tr class="memdesc:a8060c14c1635a70aef6387e95a56f3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a simple value type from a buffer starting at the specified byte offset. The method is equivalent to:  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a8060c14c1635a70aef6387e95a56f3c5">More...</a><br /></td></tr>
<tr class="separator:a8060c14c1635a70aef6387e95a56f3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa739ee0bb1aea1912f701fa78b0e6818"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aa739ee0bb1aea1912f701fa78b0e6818">Read&lt; T &gt;</a> (IntPtr source)</td></tr>
<tr class="memdesc:aa739ee0bb1aea1912f701fa78b0e6818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a simple value type from the beginning of the buffer.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aa739ee0bb1aea1912f701fa78b0e6818">More...</a><br /></td></tr>
<tr class="separator:aa739ee0bb1aea1912f701fa78b0e6818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd88d85e3cd069bb1e5bcd54acb5998"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#abbd88d85e3cd069bb1e5bcd54acb5998">Write&lt; T &gt;</a> (T value, byte[] target, int index)</td></tr>
<tr class="memdesc:abbd88d85e3cd069bb1e5bcd54acb5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a simple value type to a buffer at the specified byte offset.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#abbd88d85e3cd069bb1e5bcd54acb5998">More...</a><br /></td></tr>
<tr class="separator:abbd88d85e3cd069bb1e5bcd54acb5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af008f3d47c7f660a6350462f53c37c5a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#af008f3d47c7f660a6350462f53c37c5a">Write&lt; T &gt;</a> (T value, IntPtr target)</td></tr>
<tr class="memdesc:af008f3d47c7f660a6350462f53c37c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a simple value type to buffer at the specified byte offset.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#af008f3d47c7f660a6350462f53c37c5a">More...</a><br /></td></tr>
<tr class="separator:af008f3d47c7f660a6350462f53c37c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0410ecb17688f0f68e44461e038119c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a0410ecb17688f0f68e44461e038119c6">Copy&lt; T &gt;</a> (byte[] src, int srcIndex, T[] dest, int destIndex, int length)</td></tr>
<tr class="memdesc:a0410ecb17688f0f68e44461e038119c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a specified number of items from a buffer starting at a particular offset to a destination array starting at a particular index. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a0410ecb17688f0f68e44461e038119c6">More...</a><br /></td></tr>
<tr class="separator:a0410ecb17688f0f68e44461e038119c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a119914bbcc983ec3942d349a6879ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a2a119914bbcc983ec3942d349a6879ba">Copy&lt; T &gt;</a> (IntPtr src, int srcIndex, T[] dest, int destIndex, int length)</td></tr>
<tr class="memdesc:a2a119914bbcc983ec3942d349a6879ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a specified number of items from a buffer starting at a particular offset to a destination array starting at a particular index. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a2a119914bbcc983ec3942d349a6879ba">More...</a><br /></td></tr>
<tr class="separator:a2a119914bbcc983ec3942d349a6879ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c9695b1752a004a384960da512a935"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aa6c9695b1752a004a384960da512a935">Copy&lt; T &gt;</a> (T[] src, int srcIndex, byte[] dest, int destIndex, int length)</td></tr>
<tr class="memdesc:aa6c9695b1752a004a384960da512a935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a specified number of items from a array starting at a particular index into a destination buffer starting at a particular offset. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aa6c9695b1752a004a384960da512a935">More...</a><br /></td></tr>
<tr class="separator:aa6c9695b1752a004a384960da512a935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04f8942793271b3699e4552a1623ebb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aa04f8942793271b3699e4552a1623ebb">Copy&lt; T &gt;</a> (T[] src, int srcIndex, IntPtr dest, int destIndex, int length)</td></tr>
<tr class="memdesc:aa04f8942793271b3699e4552a1623ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a specified number of items from a array starting at a particular index into a destination buffer starting at a particular offset. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aa04f8942793271b3699e4552a1623ebb">More...</a><br /></td></tr>
<tr class="separator:aa04f8942793271b3699e4552a1623ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd6a0c6ab0dc154b125b91f9ab50758"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a2fd6a0c6ab0dc154b125b91f9ab50758">SizeOf&lt; T &gt;</a> ()</td></tr>
<tr class="memdesc:a2fd6a0c6ab0dc154b125b91f9ab50758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size, in bytes, of an instance of a simple struct.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a2fd6a0c6ab0dc154b125b91f9ab50758">More...</a><br /></td></tr>
<tr class="separator:a2fd6a0c6ab0dc154b125b91f9ab50758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8e1c552b5077a99bd10ff2885d083d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a3e8e1c552b5077a99bd10ff2885d083d">SizeOf&lt; T &gt;</a> (T value)</td></tr>
<tr class="memdesc:a3e8e1c552b5077a99bd10ff2885d083d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size, in bytes, of an instance of a simple value type.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#a3e8e1c552b5077a99bd10ff2885d083d">More...</a><br /></td></tr>
<tr class="separator:a3e8e1c552b5077a99bd10ff2885d083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8676a8296f89db8397286543539770"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aac8676a8296f89db8397286543539770">SizeOf&lt; T &gt;</a> (T[] array)</td></tr>
<tr class="memdesc:aac8676a8296f89db8397286543539770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total size, in bytes, of an array of simple struct elements.  <a href="class_microsoft_1_1_psi_1_1_common_1_1_buffer_ex.html#aac8676a8296f89db8397286543539770">More...</a><br /></td></tr>
<tr class="separator:aac8676a8296f89db8397286543539770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides static methods to efficiently read and write simple value types as well as arrays of simple value types from/to memory buffers (managed or unmanaged). Similar to System.Buffer, but works with any simple struct, not just primitive types. The simple value types supported by this class can only contain fields of primitive types or other simple value types. For accessing unmanaged memory as an array of strong-typed elements, see UnmanagedArray&lt;T&gt;. For efficient reading and writing of complex types, see the <a class="el" href="namespace_microsoft_1_1_psi_1_1_serialization.html">Serialization</a> namespace. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0410ecb17688f0f68e44461e038119c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0410ecb17688f0f68e44461e038119c6">&#9670;&nbsp;</a></span>Copy&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Microsoft.Psi.Common.BufferEx.Copy&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a specified number of items from a buffer starting at a particular offset to a destination array starting at a particular index. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source buffer to copy from.</td></tr>
    <tr><td class="paramname">srcIndex</td><td>The zero-based byte offset into src from which copying begins.</td></tr>
    <tr><td class="paramname">dest</td><td>The one-dimensional destination array.</td></tr>
    <tr><td class="paramname">destIndex</td><td>The zero-based index in the destination array at which copying begins.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to copy.</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a2a119914bbcc983ec3942d349a6879ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a119914bbcc983ec3942d349a6879ba">&#9670;&nbsp;</a></span>Copy&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Microsoft.Psi.Common.BufferEx.Copy&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a specified number of items from a buffer starting at a particular offset to a destination array starting at a particular index. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source buffer to copy from.</td></tr>
    <tr><td class="paramname">srcIndex</td><td>The zero-based byte offset into src from which copying begins.</td></tr>
    <tr><td class="paramname">dest</td><td>The one-dimensional destination array.</td></tr>
    <tr><td class="paramname">destIndex</td><td>The zero-based index in the destination array at which copying begins.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to copy.</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.CopyToArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IntPtr</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>src</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>srcIndex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>dest</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>destIndex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>length</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa6c9695b1752a004a384960da512a935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c9695b1752a004a384960da512a935">&#9670;&nbsp;</a></span>Copy&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Microsoft.Psi.Common.BufferEx.Copy&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a specified number of items from a array starting at a particular index into a destination buffer starting at a particular offset. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source array to copy from.</td></tr>
    <tr><td class="paramname">srcIndex</td><td>The zero-based byte index into src from which copying begins.</td></tr>
    <tr><td class="paramname">dest</td><td>The destination buffer.</td></tr>
    <tr><td class="paramname">destIndex</td><td>The zero-based offset in the destination buffer at which copying begins.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to copy.</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa04f8942793271b3699e4552a1623ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04f8942793271b3699e4552a1623ebb">&#9670;&nbsp;</a></span>Copy&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Microsoft.Psi.Common.BufferEx.Copy&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a specified number of items from a array starting at a particular index into a destination buffer starting at a particular offset. Similar to System.Buffer.BlockCopy(Array, int, Array, int, int), but works for any simple struct, not just primitive types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source array to copy from.</td></tr>
    <tr><td class="paramname">srcIndex</td><td>The zero-based byte index into src from which copying begins.</td></tr>
    <tr><td class="paramname">dest</td><td>The destination buffer.</td></tr>
    <tr><td class="paramname">destIndex</td><td>The zero-based offset in the destination buffer at which copying begins.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to copy.</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.CopyFromArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>src</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>srcIndex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IntPtr</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>dest</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>destIndex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>length</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8060c14c1635a70aef6387e95a56f3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8060c14c1635a70aef6387e95a56f3c5">&#9670;&nbsp;</a></span>Read&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T Microsoft.Psi.Common.BufferEx.Read&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a simple value type from a buffer starting at the specified byte offset. The method is equivalent to: </p>
<p><code>target = *(T*)(&amp;source + index)</code></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The buffer to read from.</td></tr>
    <tr><td class="paramname">index</td><td>The byte offset in the buffer where the instance to read starts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from the buffer.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa739ee0bb1aea1912f701fa78b0e6818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa739ee0bb1aea1912f701fa78b0e6818">&#9670;&nbsp;</a></span>Read&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T Microsoft.Psi.Common.BufferEx.Read&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a simple value type from the beginning of the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The buffer to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from the buffer.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.ReadValue&lt;T&gt;</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>source</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a2fd6a0c6ab0dc154b125b91f9ab50758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd6a0c6ab0dc154b125b91f9ab50758">&#9670;&nbsp;</a></span>SizeOf&lt; T &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Microsoft.Psi.Common.BufferEx.SizeOf&lt; T &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the size, in bytes, of an instance of a simple struct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, of an instance of a simple struct.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a3e8e1c552b5077a99bd10ff2885d083d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8e1c552b5077a99bd10ff2885d083d">&#9670;&nbsp;</a></span>SizeOf&lt; T &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Microsoft.Psi.Common.BufferEx.SizeOf&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the size, in bytes, of an instance of a simple value type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The simple value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, of an instance of a simple value type.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aac8676a8296f89db8397286543539770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8676a8296f89db8397286543539770">&#9670;&nbsp;</a></span>SizeOf&lt; T &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Microsoft.Psi.Common.BufferEx.SizeOf&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the total size, in bytes, of an array of simple struct elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array of simple struct elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total size, in bytes, of an array of simple struct elements.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>array.Length</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abbd88d85e3cd069bb1e5bcd54acb5998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd88d85e3cd069bb1e5bcd54acb5998">&#9670;&nbsp;</a></span>Write&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Microsoft.Psi.Common.BufferEx.Write&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a simple value type to a buffer at the specified byte offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
    <tr><td class="paramname">target</td><td>The buffer to write to.</td></tr>
    <tr><td class="paramname">index</td><td>The byte offset in the buffer where the specified value will be written.</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af008f3d47c7f660a6350462f53c37c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af008f3d47c7f660a6350462f53c37c5a">&#9670;&nbsp;</a></span>Write&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Microsoft.Psi.Common.BufferEx.Write&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a simple value type to buffer at the specified byte offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the simple value type to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to write.</td></tr>
    <tr><td class="paramname">target</td><td>The buffer to write to.</td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>MemoryAccess.WriteValue</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>value</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>target</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
</div><!-- contents -->
<!-- Copyright (c) Microsoft Corporation. All rights reserved.
     Licensed under the MIT License. -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer">
  <small>
    <a href="https://go.microsoft.com/fwlink/?LinkId=521839">Privacy & Cookies</a>&nbsp;|&nbsp;
    <a href="https://go.microsoft.com/fwlink/?LinkId=246338">Terms Of Use</a>&nbsp;|&nbsp;
    <a href="https://go.microsoft.com/fwlink/?LinkId=506942">Trademarks</a>&nbsp;|&nbsp; &nbsp;&#9400;&nbsp;Microsoft
    <img class="footer" src="MSLogoGreySmall.png" alt="Microsoft" Height="40" /> Generated by&nbsp;
    <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen" />
    </a>1.8.18
  </small>
</address>
</body>
</html>